# Pricing Service 架构说明

## 设计理念

本定价服务采用**阶段化处理模式**和**内部数据结构模式**，实现了高度模块化和可扩展的定价计算系统。

## 核心设计模式

### 1. 阶段化处理模式 (Phase-based Processing)

定价计算被分解为多个独立的阶段，每个阶段包含：
- **Preprocessors**: 预处理逻辑，为计算做准备
- **Calculators**: 计算逻辑，执行具体的价格计算
- **Aggregators**: 聚合逻辑，汇总计算结果

这种设计的优势：
- ✅ 职责分离：每个阶段专注于特定任务
- ✅ 易于扩展：添加新阶段不影响现有逻辑
- ✅ 便于测试：可以单独测试每个阶段
- ✅ 支持并行：某些阶段可以并行执行

### 2. 内部数据结构模式 (Internal Data Structure)

使用统一的 `PricingInternalData` 结构存储：
- 计算输入数据
- 中间计算结果
- 最终计算结果

这种设计的优势：
- ✅ 格式统一：不同输入可以转换为统一格式
- ✅ 灵活输出：可以从统一格式转换为不同输出
- ✅ 数据完整：保留完整的计算过程数据
- ✅ 易于调试：可以查看任意阶段的中间结果

### 3. 适配器模式 (Adapter Pattern)

使用适配器将内部数据转换为不同的输出格式：
- 支持多种 API 接口
- 支持不同运营商的需求
- 灵活响应格式

## 数据流

```
┌─────────────┐
│   Request   │
└──────┬──────┘
       │
       ▼
┌─────────────────────┐
│  PricingEngine      │
│  - 构建计算上下文    │
│  - 调用执行器        │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│  PricingInternalData│
│  - line_items       │
│  - facts            │
│  - execution_phases │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│     Executor        │
│  - 按阶段执行        │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│      Phases         │
│  ┌──────────────┐  │
│  │ LIST_PRICE   │  │
│  │ DISCOUNT     │  │
│  │ FEE          │  │
│  │ TAX          │  │
│  │ TOTAL        │  │
│  └──────────────┘  │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│    Calculators      │
│  - BasePrice        │
│  - Discount         │
│  - Fee              │
│  - Tax              │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│   Aggregators       │
│  - 汇总各组件价格    │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│  Output Adapter     │
│  - 转换为输出格式    │
└──────┬──────────────┘
       │
       ▼
┌─────────────┐
│  Response   │
└─────────────┘
```

## 价格计算逻辑

### 价格组件 (Components)

每个 line_item 包含多个价格组件：
- **Origin**: 基础价格
- **Discount**: 折扣（负数）
- **Fee**: 费用
- **Tax**: 税费
- **Proration**: 按比例计算（如退款）

### 价格聚合公式

```
list_price = base_price
gross_price = list_price + fee_amount
net_price = gross_price - discount_amount + tax_amount
total_price = sum(net_price for all items)
```

## 扩展点

### 添加新的计算阶段

1. 在 `utils/Enums.lua` 中添加新的 `PHASE_TYPE`
2. 在 `struct/Phases.lua` 中定义新阶段
3. 创建对应的 Calculator
4. 在 `PricingInternalData` 的 `execution_phases` 中添加新阶段

### 添加新的计算器

1. 在 `calculator/` 目录创建新的计算器文件
2. 实现 `execute` 函数
3. 在对应的 Phase 中注册

### 添加新的输出格式

1. 在 `struct/output/Adapter.lua` 中添加新的转换函数
2. 或创建新的适配器文件

## 性能考虑

1. **批量处理**: 支持批量计算多个商品
2. **缓存**: 可以缓存基础价格、税费率等
3. **并行计算**: 某些阶段可以并行执行
4. **延迟计算**: 某些计算可以延迟到需要时执行

## 错误处理

- 每个函数都返回 `(result, error)` 格式
- 使用统一的错误码和错误格式
- 记录详细的错误日志
- 支持错误恢复和重试

## 测试策略

1. **单元测试**: 测试每个 Calculator 和 Aggregator
2. **集成测试**: 测试完整的计算流程
3. **端到端测试**: 测试 API 接口
4. **性能测试**: 测试大量数据的处理能力
